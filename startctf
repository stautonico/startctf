#!/usr/bin/env python3
import configparser
import os

import requests

from startctfutil import __version__, CONFIG_DEFAULT_VALUES
from startctfutil.arg_parser import parse_args, get_arg
from startctfutil.commands import load_commands
from startctfutil.config import init_config
from startctfutil.io import info, success, warn, error


# Import all the tools here so their arguments are added to the parser
# for category in SUPPORTED_TOOLS:
#     for tool in SUPPORTED_TOOLS[category]:
#         importlib.import_module(f"startctfutil.tools.{tool}")

def install_manpage_handler():
    if os.geteuid() != 0:
        error("You must be root to install the manpage. Try running with sudo.")
        exit(1)
    else:
        info("Downloading manpage...")
        r = requests.get("http://raw.githubusercontent.com/stautonico/startctf/main/man/startctf.1")
        if r.status_code != 200:
            error(f"Failed to download manpage. Please try again later. (Status code: {r.status_code})")
            exit(1)
        else:
            if not os.path.exists("/usr/share/man/man1"):
                error("Manpage directory not found. Please open an issue on GitHub.")
                exit(1)
            else:
                import gzip
                # Gzip the manpage and write it to the manpage directory
                with open("/usr/share/man/man1/startctf.1.gz", "wb") as f:
                    f.write(gzip.compress(r.text.encode()))
                success("Manpage installed successfully!")
                exit(0)


def init_config_handler():
    config_path = get_arg("config_path",
                          default=os.path.join(os.path.expanduser("~"), ".config", "startctf", "config"))

    # Check if the given path is a directory or file
    if os.path.isdir(config_path):
        config_path = os.path.join(config_path, "config")

    # Check if the config file already exists
    if os.path.exists(config_path) and not get_arg("force"):
        warn(f"Config file already exists at {config_path}.")
        if not input("Overwrite? [y/N] ").lower().startswith("y"):
            exit(0)

    info(f"Generating config at {config_path}...")

    # Create the new config object
    config = configparser.ConfigParser()
    for section, values in CONFIG_DEFAULT_VALUES.items():
        config.add_section(section)
        for key, value in values.items():
            config.set(section, key, str(value))

    # Create the config file
    try:
        fd = open(config_path, "w")
        # Write the config header
        fd.write(f"# StartCTF Config V{__version__}\n")
        config.write(fd)
        fd.close()
    except (FileNotFoundError, PermissionError) as e:
        error(f"Could not create config file at {config_path}. ({e})")
        exit(1)

    success("Config file created successfully!")

def update_config_handler():
    # TODO: Implement
    error("This feature is not yet implemented.")


def main():
    load_commands()
    parse_args()
    init_config()
    # We have to import this after the config is initialized (because otherwise it'll be None)
    from startctfutil.config import CONFIG_VERSION

    if CONFIG_VERSION != __version__ and CONFIG_VERSION is not None:
        warn(
            f"Config version is {CONFIG_VERSION}, but the current version is {__version__}. Please run 'startctf --update-config' to update the config.")

    if get_arg("install_manpage"):
        install_manpage_handler()

    if get_arg("init_config"):
        init_config_handler()

    if get_arg("update_config"):
        update_config_handler()

    # run()  # Run the command passed to argparse

    # TODO: Figure out how to add arguments from a tool into the `start/new` script
    # TODO: Add ability to use rustscan instead of nmap
    # TODO: Use type hints everywhere
    # TODO: Add --init-config option to create a config file with default values (optional --path argument)
    # TODO: Use translations file for all user-facing strings (i18n)
    # TODO: Include autocompletions for bash and zsh
    # TODO: Write github actions to automatically build and upload to pypi


if __name__ == '__main__':
    main()
