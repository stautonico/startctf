#!/usr/bin/env python3
import importlib
import os

import requests

from startctfutil import __version__
from startctfutil.arg_parser import parse_args, get_arg, set_arg
from startctfutil.commands import load_commands
from startctfutil.config import init_config
from startctfutil.files import create_directory_template
from startctfutil.io import info, success, warn, error
from startctfutil.readme import README, ReadmeSection, HeadingLevel
from startctfutil.scripts import SUPPORTED_SCRIPTS
from startctfutil.tools import get_preferred_tool, try_import_preferred_tool


# Import all the tools here so their arguments are added to the parser
# for category in SUPPORTED_TOOLS:
#     for tool in SUPPORTED_TOOLS[category]:
#         importlib.import_module(f"startctfutil.tools.{tool}")

def main():
    load_commands()
    parse_args()
    init_config()
    # We have to import this after the config is initialized (because otherwise it'll be None)
    from startctfutil.config import CONFIG_VERSION

    if CONFIG_VERSION != __version__ and CONFIG_VERSION is not None:
        warn(
            f"Config version is {CONFIG_VERSION}, but the current version is {__version__}. Please run 'startctf --update-config' to update the config.")

    if get_arg("install_manpage"):
        if os.geteuid() != 0:
            error("You must be root to install the manpage. Try running with sudo.")
            exit(1)
        else:
            info("Downloading manpage...")
            r = requests.get("http://raw.githubusercontent.com/stautonico/startctf/main/man/startctf.1")
            if r.status_code != 200:
                error(f"Failed to download manpage. Please try again later. (Status code: {r.status_code})")
                exit(1)
            else:
                if not os.path.exists("/usr/share/man/man1"):
                    error("Manpage directory not found. Please open an issue on GitHub.")
                    exit(1)
                else:
                    import gzip
                    # Gzip the manpage and write it to the manpage directory
                    with open("/usr/share/man/man1/startctf.1.gz", "wb") as f:
                        f.write(gzip.compress(r.text.encode()))
                    success("Manpage installed successfully!")
                    exit(0)

    if get_arg("list_scripts"):
        info("Supported scripts:")
        for script in SUPPORTED_SCRIPTS:
            info(f"  {script}")
        exit(0)

    if get_arg("download_script"):
        # Check if we're in a startctf directory
        if not os.path.exists(".startctf"):
            error("You must be in a startctf directory to download a script.")
            exit(1)

        to_download = get_arg("download_script").lower()
        if to_download not in SUPPORTED_SCRIPTS:
            error(f"Script '{to_download}' is not supported. Use --list-scripts to see a list of supported scripts.")
            exit(1)
        else:
            info(f"Downloading script '{to_download}'...")
            try:
                script_module = importlib.import_module(f"startctfutil.scripts.{to_download}")
                script = getattr(script_module, to_download)()
                script.obtain()
                success(f"Script '{to_download}' downloaded successfully!")
                exit(0)
            except ModuleNotFoundError:
                error(f"Script '{to_download}' not found. Please open an issue on GitHub.")
                exit(1)
            except Exception as e:
                error(f"Failed to download script '{to_download}'. Please open an issue on GitHub. (Error: {e})")

    # TODO: Add ability to use rustscan instead of nmap
    # TODO: Use type hints everywhere
    # TODO: Add --init-config option to create a config file with default values (optional --path argument)
    # TODO: Add ability to download common tools from where ever they come from and put them in the tools directory
    # TODO: Use translations file for all user-facing strings (i18n)
    # TODO: Include autocompletions for bash and zsh

    # Create the directory template
    create_directory_template(get_arg("name"))

    README.add_section(ReadmeSection(get_arg("name"), HeadingLevel.H1))

    # Create the README template
    # create_readme_template(get_arg("name"), get_arg("ip"))

    if not get_arg("silent_tools"):
        info("Note: Spawned xterm windows may be stacked on top of each other, move them around to see them all")

    network_scanner_thread = None
    network_scanner = None
    preferred_tool = get_preferred_tool("network_scanner")

    if (not get_arg("nmap_scan") and not get_arg("nmap_all")) and get_arg("auto_scan"):
        warn("Auto scan requires a network scan, ignoring auto scan...")
        set_arg("auto_scan", False)

    # If we have any of the operation arguments, run the tools
    if get_arg("nmap_scan"):
        if preferred_tool is None:
            warn("No network scanner found, skipping network scan")
        else:
            network_scanner = try_import_preferred_tool("network_scanner")
            if network_scanner is None:
                warn("No network scanner found, skipping network scan")
            else:
                network_scanner = network_scanner()
                network_scanner_thread = network_scanner.run()

    # Wait for the threads to finish
    if network_scanner_thread:
        info(f"Waiting for {preferred_tool} to finish...")
        network_scanner_thread.join()
        success("Nmap finished")

        # Parse the nmap output
        if get_arg("nmap_all"):
            network_scanner.parse_output("logs/nmap/xml/all_ports.xml")
        else:
            network_scanner.parse_output("logs/nmap/xml/initial.xml")

        # TODO: Rebuild this to support multiple tools (this only supports nmap)
        if get_arg("auto_scan"):
            # TODO: Find a way to get this result without having to re-parse the nmap output
            if get_arg("nmap_all"):
                nmap_output = "logs/nmap/xml/all_ports.xml"
            else:
                nmap_output = "logs/nmap/xml/initial.xml"

            result = network_scanner.parse_nmap_output_to_object(nmap_output)
            threads = {}

            for port, service in result.items():
                # TODO: Check this is a more thorough and reliable way
                if service["status"] == "open":
                    if "http" in service["service"]:
                        tool = try_import_preferred_tool("web_fuzzer")
                        if tool is None:
                            warn("No web fuzzer found, skipping web fuzzing")
                        else:
                            tool = tool(port)
                            threads[port] = {
                                "tool": tool,
                                "thread": tool.run()
                            }

            if len(threads) > 0:
                for port, data in threads.items():
                    info(f"Waiting for {data['tool'].name} on port {port} to finish...")
                    data["thread"].join()
                    success(f"{data['tool'].name} on port {port} finished")

                    data["tool"].parse_output(f"logs/{data['tool'].name}/{port}.json")

    README.write()

    success("All done, get to pwning!")


if __name__ == '__main__':
    main()
